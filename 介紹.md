
---

# Logic Pusher 3D - 專案詳解與規則說明书

> **在微觀的晶片世界中，化身為邏輯的修復者。**

**Logic Pusher 3D** 是一款結合了 **Sokoban（推箱子）** 經典玩法與 **數位邏輯電路** 原理的 3D 解謎遊戲。本專案使用 **Unity 6** 引擎開發，透過高度風格化的視覺效果與嚴謹的程式架構，展現出「程式邏輯」與「空間解謎」的完美結合。

---

## 1. 遊戲視角與世界觀 (Perspective & World)

### 👁️ 上帝視角 (God-Mode Isometric View)

玩家透過 **等角透視 (Isometric View)** 的上帝視角俯瞰整個關卡。這不僅是為了美學，更是為了讓玩家能一覽無遺地觀察電路的流向與佈局。

* **場景設定**：遊戲舞台是一塊損壞的電子電路板（PCB）。
* **玩家角色**：玩家控制一個微型的「邏輯修復單元」（Avatar），在網格狀的電路板上移動。
* **視覺回饋**：透過 Unity URP 的 **Global Bloom** 技術，通電的線路會發出耀眼的光芒，讓玩家在上帝視角下，能直觀地看見「電流」如同液體般在迷宮中流動。

---

## 2. 互動規則 (Interaction Rules)

遊戲的核心在於「推動」，但並非所有東西都能被推動。嚴格的物理限制是解謎的基礎。

### ✅ 可推動物件 (Movable Objects)

以下物件視為「邏輯元件」，玩家可以推動它們來改變電路佈局：

1. **電線方塊 (Wire Block)**：單純的導體，負責將訊號延伸。
2. **邏輯閘 (Logic Gates)**：包含 AND、OR、NOT 閘。它們是解謎的核心，具有方向性。

### ⛔ 不可推動物件 (Immovable Objects)

以下物件固定在電路板上，構成關卡的邊界或目標：

1. **電源 (Source)**：訊號的起點，恆定輸出 High 訊號。
2. **終端 (Target)**：訊號的終點，玩家的目標。
3. **障礙物 (Obstacle/Wall)**：毀損的晶片或邊界牆，完全阻擋移動。
4. **地板 (Ground)**：僅供行走，無阻擋功能。

### 🎮 推動機制 (Push Mechanics)

玩家控制的角色在推動物件時，必須遵守以下物理法則：

1. **單體推動**：一次只能推動 **一個** 方塊。
2. **後方淨空**：被推動的方塊，其「前進方向」必須是空地 (Empty) 或地板。若前方有牆或其他方塊，則推不動。
3. **無法拉動**：玩家只能「推」，不能「拉」。這意味著如果把方塊推入死角（Corner），將無法再將其移出（除非有悔步功能）。

---

## 3. 邏輯運算規則 (Logic & Circuit Rules)

本遊戲與傳統推箱子最大的不同，在於**元件的方向性**與**訊號傳遞**。

### 3.1 方向性定義 (Orientation)

每個邏輯閘都有一個明確的「朝向」（由 3D 模型外觀指示，如箭頭）：

* **前方 (Front)**：永遠是 **輸出端 (Output)**。
* **後方/側面 (Back/Sides)**：依據閘的種類，作為 **輸入端 (Input)**。

> **關鍵挑戰**：玩家不僅要將方塊推到正確位置，還必須確保它的「朝向」正確對接訊號。例如：一個朝北的 AND 閘，無法接收來自北方的訊號。

### 3.2 邏輯閘行為 (Gate Behaviors)

| 元件圖示 | 名稱 | 輸入規則 (Input) | 輸出結果 (Output) |
| --- | --- | --- | --- |
| **AND** | **及閘** | 必須 **同時** 收到來自後方與側面的訊號 (High)。 | 前方輸出 High (通電)。 |
| **OR** | **或閘** | 只要 **任一** 非前方端收到訊號 (High)。 | 前方輸出 High (通電)。 |
| **NOT** | **反閘** | 必須 **後方無訊號** (Low)。 | 前方輸出 High (通電)。(即訊號反轉) |
| **WIRE** | **導線** | 來自任一相鄰方格的訊號。 | 向所有相鄰方格傳遞訊號。 |

### 3.3 迴圈與穩定性 (Loop Stability)

若玩家構建出了邏輯迴圈（例如：NOT 閘的輸出接回自己的輸入），系統內建 **迴圈保護機制 (Loop Protection)**：

* 電路不會因為無限遞迴而導致遊戲崩潰。
* 系統會偵測已訪問路徑，將迴圈視為無效或保持前一狀態，確保遊戲體驗流暢。

---

## 4. 勝利條件 (Win Condition)

每一關的目標皆相同且明確：

1. 觀察 **Source (電源)** 的位置。
2. 推動邏輯閘與電線，鋪設出一條完整的電路。
3. 將 **High (通電)** 訊號成功傳導至 **Target (終點)** 方塊。
4. 當 Target 亮起，關卡即告破解 (Level Clear)。

---

## 🛠 技術規格摘要 (Tech Specs)

* **開發引擎**: Unity 6 (6000.0.29f1)
* **渲染管線**: URP (Universal Render Pipeline)
* **設計模式**: MVC Architecture, Strategy Pattern (邏輯演算), Command Pattern (移動系統)。
* **關卡設計**: 外部 JSON 資料驅動，支援熱抽換關卡配置。

---

*Built by [Your Name] for [Project/Class Name]*
